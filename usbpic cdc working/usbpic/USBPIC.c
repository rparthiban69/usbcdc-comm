//USBPIC by Guelbert Cool 30/10/2012
#include <18F4550.h> 
#device adc=10    // Set ADC resolution to 10Bit for lm35
#fuses HSPLL,MCLR,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOPBADEN
#use delay(clock=20000000)    
//#define use_portb_lcd TRUE
#include "LCD.C"
#include "kbd.c"
#include "usb_cdc.h"
#include "usb_desc_cdc.h"
#include <stdlib.h>


#define portb  0x0f81
//lm35
int digital_reading;  // ADC resolution is 10Bit, an 8Bit integer is not enough to hold the reading
int temp; 


//------------------------------------------------------------------
const char FONT1[32][7] ={
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   //        Space
   0xFB,0xFB,0xFB,0xFB,0xFB,0xFF,0xFB,   //        !
   0xF5,0xF5,0xF5,0xFF,0xFF,0xFF,0xFF,   //        "
   0xF5,0xF5,0xE0,0xF5,0xE0,0xF5,0xF5,   //        #
   0xFB,0xF0,0xEB,0xF1,0xFA,0xE1,0xFB,   //        $
   0xE3,0xEA,0xE5,0xFB,0xF4,0xEA,0xF8,   //        %
   0xF7,0xEB,0xEB,0xF7,0xEA,0xED,0xF2,   //        &
   0xF9,0xF9,0xFD,0xFB,0xFF,0xFF,0xFF,   //        '
   0xFD,0xFB,0xF7,0xF7,0xF7,0xFB,0xFD,   //        (
   0xF7,0xFB,0xFD,0xFD,0xFD,0xFB,0xF7,   //        )
   0xFB,0xEA,0xF1,0xFB,0xF1,0xEA,0xFB,   //        *
   0xFF,0xFB,0xFB,0xE0,0xFB,0xFB,0xFF,   //        +
   0xFF,0xFF,0xFF,0xF3,0xF3,0xFB,0xF7,   //        ,
   0xFF,0xFF,0xFF,0xF1,0xFF,0xFF,0xFF,   //        -
   0xFF,0xFF,0xFF,0xFF,0xFF,0xF3,0xF3,   //        .
   0xFF,0xFE,0xFD,0xFB,0xF7,0xEF,0xFF,   //        /
   0xF1,0xEE,0xEC,0xEA,0xE6,0xEE,0xF1,   //        0
   0xFB,0xF3,0xFB,0xFB,0xFB,0xFB,0xF1,   //        1
   0xF1,0xEE,0xFE,0xF1,0xEF,0xEF,0xE0,   //        2
   0xF1,0xEE,0xFE,0xF9,0xFE,0xEE,0xF1,   //        3
   0xFD,0xF9,0xF5,0xED,0xE0,0xFD,0xFD,   //        4
   0xE0,0xEF,0xE1,0xFE,0xFE,0xFE,0xE1,   //        5
   0xF9,0xF7,0xEF,0xE1,0xEE,0xEE,0xF1,   //        6
   0xE0,0xFE,0xFD,0xFB,0xF7,0xF7,0xF7,   //        7
   0xF1,0xEE,0xEE,0xF1,0xEE,0xEE,0xF1,   //        8
   0xF1,0xEE,0xEE,0xF0,0xFE,0xFD,0xF3,   //        9
   0xFF,0xF3,0xF3,0xFF,0xF3,0xF3,0xFF,   //        :
   0xF3,0xFB,0xF3,0xF3,0xFF,0xF3,0xF3,   //        ;        
   0xFD,0xFB,0xF7,0xEF,0xF7,0xFB,0xFD,   //        <
   0xFF,0xFF,0xF1,0xFF,0xF1,0xFF,0xFF,   //        =
   0xF7,0xFB,0xFD,0xFE,0xFD,0xFB,0xF7,   //        >
   0xF1,0xEE,0xFE,0xFD,0xFB,0xFF,0xFB};  //        ?

const char FONT2[32][7] ={
   0xF1,0xEE,0xFE,0xF2,0xEA,0xEA,0xF1,   //        @
   0xFB,0xF5,0xEE,0xEE,0xE0,0xEE,0xEE,   //        A
   0xE1,0xF6,0xF6,0xF1,0xF6,0xF6,0xE1,   //        B
   0xF1,0xEE,0xEF,0xEF,0xEF,0xEE,0xF1,   //        C
   0xE1,0xF6,0xF6,0xF6,0xF6,0xF6,0xE1,   //        D
   0xE0,0xEF,0xEF,0xE3,0xEF,0xEF,0xE0,   //        E
   0xE0,0xEF,0xEF,0xE3,0xEF,0xEF,0xEF,   //        F
   0xF1,0xEE,0xEF,0xE8,0xEE,0xEE,0xF1,   //        G
   0xEE,0xEE,0xEE,0xE0,0xEE,0xEE,0xEE,   //        H
   0xF1,0xFB,0xFB,0xFB,0xFB,0xFB,0xF1,   //        I
   0xF8,0xFD,0xFD,0xFD,0xFD,0xFD,0xF3,   //        J
   0xEE,0xED,0xEB,0xE7,0xEB,0xED,0xEE,   //        K
   0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xE0,   //        L
   0xEE,0xE4,0xEA,0xEA,0xEE,0xEE,0xEE,   //        M
   0xEE,0xE6,0xEA,0xEC,0xEE,0xEE,0xEE,   //        N
   0xF1,0xEE,0xEE,0xEE,0xEE,0xEE,0xF1,   //        O
   0xE1,0xEE,0xEE,0xE1,0xEF,0xEF,0xEF,   //        P
   0xF1,0xEE,0xEE,0xEE,0xEA,0xED,0xF2,   //        Q
   0xE1,0xEE,0xEE,0xE1,0xEB,0xED,0xEE,   //        R  
   0xF1,0xEE,0xEF,0xF1,0xFE,0xEE,0xF1,   //        S
   0xE0,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,   //        T
   0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF1,   //        U
   0xEE,0xEE,0xEE,0xF5,0xF5,0xFB,0xFB,   //        V
   0xEE,0xEE,0xEE,0xEA,0xEA,0xE4,0xEE,   //        W
   0xEE,0xEE,0xF5,0xFB,0xF5,0xEE,0xEE,   //        X
   0xEE,0xEE,0xF5,0xFB,0xFB,0xFB,0xFB,   //        Y
   0xE0,0xFE,0xFD,0xFB,0xF7,0xEF,0xE0,   //        Z
   0xF1,0xF7,0xF7,0xF7,0xF7,0xF7,0xF1,   //        [
   0xFF,0xEF,0xF7,0xFB,0xFD,0xFE,0xFF,   //        \
   0xF1,0xFD,0xFD,0xFD,0xFD,0xFD,0xF1,   //        [
   0xFB,0xF5,0xEE,0xFF,0xFF,0xFF,0xFF,   //        ^
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0};  //        _

const char FONT3[32][7] ={
   0xF3,0xF3,0xF7,0xFB,0xFF,0xFF,0xFF,   //        `
   0xFF,0xFF,0xF1,0xFE,0xF0,0xEE,0xF1,   //        a
   0xEF,0xEF,0xE9,0xE6,0xEE,0xE6,0xE9,   //        b
   0xFF,0xFF,0xF8,0xF7,0xF7,0xF7,0xF8,   //        c
   0xFE,0xFE,0xF2,0xEC,0xEE,0xEC,0xF2,   //        d
   0xFF,0xFF,0xF1,0xEE,0xE0,0xEF,0xF1,   //        e
   0xF9,0xF6,0xF7,0xE1,0xF7,0xF7,0xF7,   //        f
   0xFF,0xFF,0xF0,0xEE,0xF0,0xFE,0xF1,   //        g
   0xEF,0xEF,0xE9,0xE6,0xEE,0xEE,0xEE,   //        h
   0xFB,0xFF,0xF3,0xFB,0xFB,0xFB,0xF1,   //        i
   0xFD,0xFF,0xF9,0xFD,0xFD,0xFD,0xF3,   //        j
   0xF7,0xF7,0xF6,0xF5,0xF3,0xF5,0xF6,   //        k
   0xF3,0xFB,0xFB,0xFB,0xFB,0xFB,0xF1,   //        l
   0xFF,0xFF,0xE5,0xEA,0xEA,0xEA,0xEA,   //        m
   0xFF,0xFF,0xE9,0xE6,0xEE,0xEE,0xEE,   //        n
   0xFF,0xFF,0xF1,0xEE,0xEE,0xEE,0xF1,   //        o
   0xFF,0xFF,0xE1,0xEE,0xE1,0xEF,0xEF,   //        p
   0xFF,0xFF,0xF0,0xEE,0xF0,0xFE,0xFE,   //        q
   0xFF,0xFF,0xE9,0xE6,0xEF,0xEF,0xEF,   //        r
   0xFF,0xFF,0xF0,0xEF,0xF1,0xFE,0xE1,   //        s
   0xFB,0xFB,0xF0,0xFB,0xFB,0xFB,0xFC,   //        t
   0xFF,0xFF,0xEE,0xEE,0xEE,0xEC,0xF2,   //        u
   0xFF,0xFF,0xEE,0xEE,0xEE,0xF5,0xFB,   //        v
   0xFF,0xFF,0xEE,0xEE,0xEA,0xEA,0xF4,   //        w
   0xFF,0xFF,0xEE,0xF5,0xFB,0xF5,0xEE,   //        x
   0xFF,0xFF,0xEE,0xF5,0xFB,0xFB,0xF3,   //        y
   0xFF,0xFF,0xE0,0xFD,0xFB,0xF7,0xE0,   //        z
   0xF9,0xF7,0xF7,0xE7,0xF7,0xF7,0xF9,   //        {
   0xFB,0xFB,0xFB,0xFF,0xFB,0xFB,0xFB,   //        |
   0xF3,0xFD,0xFD,0xFC,0xFD,0xFD,0xF3,   //        }
   0xF5,0xEA,0xFF,0xFF,0xFF,0xFF,0xFF};  //        ~
//------------------------------------------------------------------
char TEXT []={"                                                        "};
int i,j,k,d,n,m,s,DATA,t=0,w;
int KEY;
char LETRA[],string[]={"0000"};
boolean scrl=false;

void config(void){
      setup_comparator(NC_NC_NC_NC);
      setup_adc(ADC_OFF);

}
void put_index(int t){
            itoa(t,10, string);
            if(usb_cdc_putready()){
            usb_cdc_putc('\0');
            usb_cdc_putc(string[0]);
            usb_cdc_putc(string[1]);
            usb_cdc_putc(string[2]);}
}

void put_led_stat(){
            if(usb_cdc_putready()){
          //  usb_cdc_putc('\0');
            usb_cdc_putc(*portb);}
} 
void put_temp(){
            if(usb_cdc_putready()){
          //  usb_cdc_putc('\0');
            usb_cdc_putc(temp/2);}
} 

void put_text(int t){
            if(usb_cdc_putready()){
          //  usb_cdc_putc('K');
            for(w=0;w<=t;w++)
            usb_cdc_putc(TEXT [w]);}
}      
void main() {

   setup_adc(ADC_CLOCK_INTERNAL); // initialize ADC with a sampling rate of Crystal/4 MHz
//   setup_adc_ports(RA0_ANALOG);   // set PIN_A0 as analog input channel
   /* ADC Initialization */ 
 //  setup_adc(ADC_OFF);
   setup_adc_ports(AN0|VSS_VDD);
//   delay_ms(1);                   // ADC module is slow, needs some time to adjust. 
//lm35
   set_adc_channel(0);            // point ADC to channel 0 for ADC reading
   
   lcd_init();
   usb_cdc_init();
   usb_init();    
   output_high(PIN_C0);
   output_low(PIN_C1);
   
   while(!usb_cdc_connected())
   do{
//lm35
      digital_reading = read_adc();    // capture current temperature reading
      if(temp != digital_reading){
      temp = digital_reading;
      put_index(t);put_led_stat();put_temp();put_text(t);}
      usb_task();
      if (usb_enumerated()){        
            output_low(PIN_C0); 
            output_high(PIN_C1);
    
            

      if(usb_cdc_kbhit()){
                
            LETRA=usb_cdc_getc();
 

            switch(LETRA){
            case  131  : output_toggle(PIN_B0); break;
            case  132  : output_toggle(PIN_B1); break;
            case  133  : output_toggle(PIN_B2); break;
            case  134  : output_toggle(PIN_B3); break;
            case  135  : output_toggle(PIN_B4); break;
            case  136  : output_toggle(PIN_B5); break;
            case  137  : output_toggle(PIN_B6); break;
            case  138  : output_toggle(PIN_B7); break;
        //  case  139  :   break;                     
          //case  140  : put_index(t); break;
            case  8    : if(t>0){t-=1;if(t==15)lcd_gotoxy(17,1); TEXT[t]=' ';lcd_putc('\b');lcd_putc(' ');lcd_putc('\b');}break;
            case '\v'  : t=0;d=0; break;
            case 13    : scrl=!scrl; break;
            case '\f'  : lcd_putc('\f');FOR(w=0;w<=t+3+8;w++)TEXT[w]=' ';d=0;t=0;break;
            case  2    : d=0;n=0;break;
            case  3    : if(t>8)d=t-8;n=0;break;
            default    : lcd_putc(LETRA);TEXT[t]=LETRA;if(t<41)t+=1;if(T==16)lcd_putc("\n");break;
        }
            put_index(t);put_led_stat();put_temp();put_text(t);
         }//      
         
      }
      
    //OUTPUT_A(0x00);OUTPUT_E(0x00);
       for(j=0;j<8;j++)
       {      
       for(i=d;i<d+8;i++)
         {
         if (TEXT [i]<='?')DATA=~FONT1[TEXT [i]-' '][j];else
         if (TEXT [i]<='_')DATA=~FONT2[TEXT [i]-'@'][j];else
         if (TEXT [i]<='~')DATA=~FONT3[TEXT [i]-'`'][j];
         if(j==7)DATA=0x00;
         for(k=0;k<8;k++)
           {
           OUTPUT_BIT(PIN_A2,shift_left(&DATA,1,0));
           if(k>=2){OUTPUT_HIGH(PIN_A1);OUTPUT_LOW (PIN_A1);}
           } 
         }
         OUTPUT_LOW (PIN_A2);
         if(scrl)
         for(k=0;k<n;k++){OUTPUT_HIGH(PIN_A1);OUTPUT_LOW (PIN_A1);}
         
         
       OUTPUT_HIGH(PIN_A3);
       delay_ms(5);
       OUTPUT_LOW (PIN_A3);
       OUTPUT_E(s+=1);
       }
       m+=1;
       if(m==5){m=0;n+=1;};
       if(n==6){
         n=0;
           if(scrl){
            d+=1;
            text[t]=' ';
            text[t+1]=' ';
            text[t+2]=' ';
            //text[t+3]=' ';
            for(w=0;w<8;w++)text[t+3+w]=text[w];
            if(d>=t+3)d=0;
            }
       } // bucle infinito.
   }while (true);
}
